To convert a Kotlin data class into a REST API using the Ktor framework, we'll go through a step-by-step process to set up a Ktor application, define the data class, and create API endpoints for it. Here's a simple example to guide you through the process.

Assumptions:
- You have an environment set up for Kotlin and Ktor development.
- You have basic knowledge of Kotlin and REST APIs.

### Step 1: Set Up Your Ktor Project

1. **Initialize your project**: You can use IntelliJ IDEA with the Ktor plugin to create a new Ktor project, or set it up manually using Gradle.

2. **Add Dependencies**: Ensure your `build.gradle.kts` file includes the necessary Ktor dependencies.

```kotlin
plugins {
    application
    kotlin("jvm") version "1.8.0"
}

application {
    mainClassName = "io.ktor.server.netty.EngineMain"
}

repositories {
    mavenCentral()
}

dependencies {
    implementation("io.ktor:ktor-server-core:2.5.0")
    implementation("io.ktor:ktor-server-netty:2.5.0")
    implementation("io.ktor:ktor-server-content-negotiation:2.5.0")
    implementation("io.ktor:ktor-serialization-kotlinx-json:2.5.0")
    testImplementation("io.ktor:ktor-server-tests:2.5.0")
}
```

### Step 2: Define Your Data Class

Let's say you have a simple Kotlin data class:

```kotlin
data class Point(val x: Int, val y: Int)
```

### Step 3: Set Up Your Ktor Application with a REST API

You'll need to create an application configuration that includes modules to handle serialization and an endpoint to manage your `Point` data class.

#### Create the Application Entry Point

Create a file named `Application.kt`, where you configure the server.

```kotlin
import io.ktor.application.*
import io.ktor.features.*
import io.ktor.response.*
import io.ktor.request.*
import io.ktor.routing.*
import io.ktor.serialization.*
import io.ktor.server.engine.*
import io.ktor.server.netty.*
import kotlinx.serialization.Serializable

@Serializable
data class Point(val x: Int, val y: Int)

fun main() {
    embeddedServer(Netty, port = 8080, module = Application::module).start(wait = true)
}

fun Application.module() {
    install(ContentNegotiation) {
        json()
    }
    
    routing {
        route("/points") {
            get {
                // Return a sample Point
                val point = Point(10, 20)
                call.respond(point)
            }
        
            post {
                // Receive a Point from the client
                val point = call.receive<Point>()
                call.respond("Received Point: x=${point.x}, y=${point.y}")
            }
        }
    }
}
```

### Step 4: Running Your Ktor Application

You can run your application using IntelliJ IDEA's run configuration or directly through the command line with Gradle.

```bash
./gradlew run
```

### Explanation

- **Data Class**: We've defined a data class `Point` that represents a structure with two fields, `x` and `y`.

- **Ktor Server**: We set up a basic Ktor server using Netty that listens on port 8080.

- **ContentNegotiation**: The `ContentNegotiation` plugin is installed with support for `kotlinx.serialization` `json`.

- **Routing**:
  - The `GET` route at `/points` responds with a sample `Point`.
  - The `POST` route at `/points` allows you to send a `Point` object, which is received using the Ktor `receive` method.

This example sets up a minimal Ktor server with endpoints to handle a simple data class. You can extend this by adding more functionality, like database interaction, authentication, etc., based on your requirements.